1. **Problem_Understanding**

The goal is to design a feature set that can help a model predict the *Maximum Acceptable Latency (MAL)* for each query, using only the query text. Each row is one Korean natural-language query, mostly about retrieval, summarization, analysis, or recommendation based on a user’s personal data and context. I will not use any MAL labels; instead, I’ll design interpretable, theory-grounded features that capture cognitive load, urgency, task type, and expected computation effort, all of which are known to influence acceptable waiting time.

---

2. **Feature_Specification**

**Recommended core set** (highlighted with `★` in the table).

| feature_name | type | derived_from | definition | theoretical_rationale |
| --- | --- | --- | --- | --- |
| ★ `QL_char_len` | numeric | `queries` | Number of characters in the query (including spaces/punctuation). | Longer queries often encode more constraints and higher task complexity, which can increase user tolerance for latency (more “work” expected from the system). |
| ★ `QL_word_len` | numeric | `queries` | Number of whitespace-separated tokens (rough proxy for word count). | More tokens typically mean more detailed requests, suggesting higher cognitive and computational load, and slightly higher acceptable latency. |
| ★ `QL_has_time_ref` | binary | `queries` | 1 if query contains explicit temporal phrases (e.g., “오늘”, “어제”, “지난주”, “지난달”, “올해”, “이번 주/달”, “작년”, “상반기”, “주말”), else 0. | Time-referenced queries often relate to logs/records and retrospective analysis; users may expect some processing but might also perceive them as “simple lookup”, affecting acceptable latency in a systematic way. |
| ★ `QL_time_granularity` | ordinal | `queries` | Encoded time granularity: 0 = none, 1 = vague period (“최근”, “이맘때쯤”), 2 = day-level (“어제”, “오늘”, specific 날짜), 3 = week/month/season (“지난주”, “이번 달”, “여름”), 4 = year-level (“작년”, “올해”, “지난해”). | Finer granularity often implies more precise filtering over logs; coarser periods suggest aggregation. Perceived task complexity and expected processing time differ by granularity, influencing MAL. |
| ★ `QL_has_future_ref` | binary | `queries` | 1 if refers to future (“내일”, “이번 주말에 뭐 입으면”, “오늘 목표…”, “지금 30분 정도 여유 시간에”), else 0. | Future-oriented queries (planning, recommendations “for now/soon”) usually feel more time-sensitive, reducing acceptable latency compared to purely retrospective analysis. |
| ★ `QL_urgency_level` | ordinal | `queries` | Heuristic scale: 0 = no immediacy cue; 1 = weak (“이번 달에…”, “올해…”), 2 = moderate (“오늘…”, “이번 주말…”, “출퇴근 시간에 볼 만한…”), 3 = strong immediate context (“지금…”, “현재 위치…”, “오늘 목표…”, “오늘같은 날씨에…”). | Higher urgency/time-coupling (now, here, this session) generally lowers MAL; users expect faster responses when they are in-the-moment or on-the-go. |
| ★ `QL_task_type` | categorical | `queries` | Manual rule-based label: {`retrieve_item`, `retrieve_aggregate_stats`, `compare_stats`, `summarize`, `generate_list`, `recommend`, `optimize/plan`}. E.g., “사진 보여줘/찾아줘” → `retrieve_item`; “…비교해줘” → `compare_stats`; “…요약해줘” → `summarize`; “…추천해줘” → `recommend`; “…리스트 만들어줘” → `generate_list`. | Different task types have different expected “heaviness”: retrieval feels light/fast; summarization, planning, or recommendation feel heavier, making users more tolerant of longer latency. |
| ★ `QL_data_modalities` | categorical | `queries` | Dominant data type referenced: {`photo/video`, `text_note/doc`, `transaction/finance`, `activity/health`, `media_history`, `location/travel`, `schedule/calendar`, `commerce/shopping`, `communication/chat`, `other`}. Use keyword rules (e.g., “사진/영상”→`photo/video`; “결제/가계부”→`transaction/finance`; “걸음/칼로리/운동”→`activity/health`). | Different modalities imply different back-end pipelines (vision search vs. log aggregation vs. NLP summarization) and different user expectations about processing time, thus different MAL. |
| ★ `QL_personalization_depth` | ordinal | `queries` | 0 = generic (no explicit “내/나/내가 자주…” or named contacts), 1 = lightly personalized (mentions self “나/내” or a named friend once), 2 = strongly personalized (based on long-term behavior: “내가 자주 보는/듣는/사는…”, “내 건강 데이터”, “내 일정(캘린더)”, “재희랑 했던 대화를 분석해서…”). | Deeper personalization suggests complex data fusion and analysis over personal history; users may expect heavier computation and accept more latency. |
| ★ `QL_requires_history_span` | ordinal | `queries` | 0 = no history (purely current context, e.g., “오늘 날씨에 적합한 패션 스타일”), 1 = short history (≤1주: “지난주”, “이번 주”), 2 = medium (≤1달: “이번 달”, “지난달”), 3 = long (≥수개월/년: “올해”, “작년”, “지난해”, “상반기”, “여름휴가 동안”). | Longer history windows imply more data to scan/aggregate; users often infer more back-end effort and may tolerate higher latency. |
| ★ `QL_requires_external_knowledge` | binary | `queries` | 1 if satisfying the query clearly needs external world knowledge or open-domain search (e.g., “한국사 강의 추천”, “원두 구독 서비스 추천”, “OTT 구독 서비스 추천”, “도서 추천”), beyond just personal logs; else 0. | When external knowledge/search is expected, users generally anticipate slower responses and accept higher MAL. |
| ★ `QL_location_coupled` | binary | `queries` | 1 if query depends on current/explicit location (“현재 위치에서…”, “집 근처…”, “지금 여기…”, “한강 산책 코스”), else 0. | Location-coupled and “nearby” tasks often happen on-the-move; users may expect snappy responses (lower MAL) despite potential heavy computation. |
| ★ `QL_output_size_expectation` | ordinal | `queries` | 1 = small (one item/answer: “어디였지?”, “언제였지?”, “몇 번이나 했지?”), 2 = medium list (e.g., “리스트 보여줘”, “순서대로 알려줘”), 3 = large/structured output (e.g., “가계부로 작성해줘”, “요약 정리해줘”, “쇼핑리스트 만들어줘”). | Larger expected outputs usually entail more processing and formatting, and users are more tolerant of extra latency for “big” answers. |
| ★ `QL_comparison_required` | binary | `queries` | 1 if comparing two or more periods/entities (“비교해줘”, “이번 달과 지난달”, “여행 갔을 때 평소보다…”), else 0. | Comparative/analytic tasks imply aggregation over multiple slices of data, which users perceive as more complex than simple lookup, increasing acceptable latency. |
| ★ `QL_summary_required` | binary | `queries` | 1 if explicitly asking to “요약해줘”, “한 장으로 요약 정리해줘”, “내용을 요약해줘”, else 0. | Summarization over long texts (e.g., 메신저 대화, 회의록, 강의노트) is cognitively and computationally heavy; users expect slower responses and higher MAL. |
| ★ `QL_recommender_task` | binary | `queries` | 1 if main verb is “추천해줘/추천해줄래?”, else 0. | Recommendation is perceived as more “thinking” than retrieval; users often accept more latency for high-quality recommendations. |
| ★ `QL_visual_input_ref` | binary | `queries` | 1 if query references visual input as the basis (“이 사진에 있는…”, “이 노트에 있는…”, “사진에 있는 이런…”, “이 메모에 있는…”, “이 논문에 있는…”, “이 회의록에 있는…”), else 0. | Visual-input-based tasks (image understanding + retrieval/recommendation) are perceived as heavy; users may allow longer MAL than for text-only queries. |
| ★ `QL_social_context` | binary | `queries` | 1 if query involves named people/relationships or group chats (“소연이”, “지민이”, “성훈이”, “나연이”, “재희”, “친구들”, “가족”, “팀원들”, “동료들”), else 0. | Socially contextual tasks (e.g., planning with friends, analyzing chats) may feel more “live” and time-sensitive (lower MAL) or more complex (higher MAL); including this feature allows the model to learn the direction empirically. |
| ★ `QL_device_likely_mobile` | binary | `queries` | 1 if query strongly suggests mobile/on-the-go use (e.g., “현재 위치에서 걸어서 갈 수 있는…”, “지금 여기…할인되는 카드”, “출퇴근 시간에 볼 만한 영상”), else 0. | On mobile/in-situ contexts, users typically demand lower latency due to higher time pressure and shorter attention spans. |
| ★ `QL_goal_type` | categorical | `queries` | {`remember/recall`, `monitor/track`, `analyze/compare`, `plan/optimize`, `entertain`, `shop/save_money`}. Map via keywords: “어디였지/언제였지/뭐였지”→`remember/recall`; “몇 번이나 했지/총 얼마나 썼지”→`monitor/track`; “비교해줘/분석해서”→`analyze/compare`; “추천해줘/추천해줄래”→`plan/optimize` or `entertain` depending on domain; “최저가/할인가/특가/저렴한”→`shop/save_money`. | Different goals carry different urgency and satisfaction curves: recall/lookup tends to require snappy answers; planning/optimization and entertainment tolerate more latency. |

---

### Additional optional features (for richer models)

| feature_name | type | derived_from | definition | theoretical_rationale |
| --- | --- | --- | --- | --- |
| `QL_question_formality` | ordinal | `queries` | 0 = imperative without question ending (“…해줘”), 1 = polite question (“…해줄래?”, “…뭐였지?”, “…어디였지?”). | Polite/indirect forms can correlate with exploratory or less time-pressured tasks; more direct imperative may signal higher urgency. |
| `QL_contains_numeric_amount` | binary | `queries` | 1 if numeric amounts or counts appear (e.g., “5만원”, “10만원”, “만보”, “30분”), else 0. | Explicit numbers often indicate precise, goal-oriented tasks (budget, time, distance) which may feel more urgent or high-stakes, lowering MAL. |
| `QL_financial_domain` | binary | `queries` | 1 if involves money/expenses (“결제”, “가계부”, “저축”, “용돈”, “관리비”, “카드”, “쿠폰”, “할인”, “최저가”, “특가”), else 0. | Financial tasks can feel more important and error-sensitive; users may be less tolerant of delays or may accept some delay for “careful” analysis, but in any case MAL likely differs from entertainment tasks. |
| `QL_health_activity_domain` | binary | `queries` | 1 if about 운동, 걸음 수, 칼로리, 활동량, 건강 데이터, 식단, 수면, etc., else 0. | Health-related tasks can be moderately high-stakes and often tied to daily routines; users may want reasonably fast but not instantaneous responses. |
| `QL_media_domain` | binary | `queries` | 1 if about 음악, 유튜브, 드라마, 영화, 게임, 팟캐스트, 라디오, OTT, SNS, etc., else 0. | Media/entertainment tasks are typically low-stakes; users may tolerate more latency for high-quality recommendations but dislike lag for simple recall (e.g., “어제 들은 노래 제목”). |
| `QL_shopping_domain` | binary | `queries` | 1 if about 쇼핑, 물건, 마트, 다이소, 올리브영, 편의점, 인테리어, 구독 서비스, 최저가, etc., else 0. | Shopping queries often involve decision-making and price comparison; users may accept some latency for better deals but expect quick responses in-store (“지금 여기…할인되는 카드”). |
| `QL_travel_location_domain` | binary | `queries` | 1 if about 여행, 캠핑, 공원, 산책 코스, 레스토랑/호텔/식장 위치, “어디였지?”, etc., else 0. | Travel/location tasks often have contextual urgency (during trip, walking); MAL expectations can differ from offline analytic tasks. |
| `QL_calendar_schedule_domain` | binary | `queries` | 1 if about 일정, 약속, 회의, 세미나, 미팅, 생일, 기념일, etc., else 0. | Calendar-related queries are often time-critical (before a meeting), lowering acceptable latency. |
| `QL_chat_analysis` | binary | `queries` | 1 if explicitly about 메신저/대화 내용 분석/요약 (“단체 메신저 방에서 나눈 대화 내용을 요약해줘”, “재희랑 했던 대화를 분석해서…”), else 0. | Chat analysis implies long text processing and personalization; users may expect heavier computation and accept higher MAL. |
| `QL_requires_cross_modal` | binary | `queries` | 1 if combining different data types (e.g., “내 건강 데이터를 참고해서 오늘 식단을 추천해줘” = health logs + nutrition knowledge; “사진에 있는 이런 가방을 구경해 볼 수 있는 곳” = image + local search), else 0. | Cross-modal integration is cognitively and computationally complex; users often accept more latency for such “smart” tasks. |
| `QL_temporal_comparison` | binary | `queries` | 1 if comparing different time periods (“지난달과 비교했을 때 이번 달…”, “작년과 비교했을 때 올해…”, “여행 갔을 때 평소보다…”), else 0. | Temporal comparison requires multi-window aggregation; perceived as more complex than single-period stats, raising acceptable latency. |
| `QL_long_horizon_planning` | binary | `queries` | 1 if about longer-term patterns or annual/half-year summaries (“올해 상반기에…몇 번이나 샀지?”, “지난해에 약속이 몇 번…”, “올해 가장 많이…”), else 0. | Long-horizon analysis feels like “reporting/analytics”; users are more tolerant of waiting for such overviews. |
| `QL_preference_learning` | binary | `queries` | 1 if asks to “분석해서 … 좋아할 만한/맞는 … 추천해줘”, or “내가 자주 … 기준으로 … 추천해줘”, else 0. | Explicit preference-learning implies model-based reasoning; users expect more “thinking” and thus higher MAL. |
| `QL_cost_savings_focus` | binary | `queries` | 1 if focused on saving money (“최저가”, “할인가”, “특가”, “저렴한 가격”), else 0. | Cost-saving tasks may be high-value; users could accept slightly more latency if it yields better savings, but may also be impatient in-store; model can learn this nuance. |
| `QL_weather_coupled` | binary | `queries` | 1 if mentions 날씨 (“오늘같은 날씨에 하면 좋을 운동”, “오늘 날씨에 적합한 패션 스타일”), else 0. | Weather-coupled tasks are highly context-dependent and often immediate (today/now), usually reducing MAL. |
| `QL_session_length_hint` | ordinal | `queries` | 0 = single quick lookup implied; 1 = medium session (e.g., “30분 정도 여유 시간에 볼만한 …”), 2 = longer or repeated use (e.g., 구독 서비스, 장기 습관 분석). | If the user is planning a longer session, they may tolerate slightly higher one-off latency at the start. |
| `QL_requires_ranking` | binary | `queries` | 1 if asks for ordering/ranking (“순서대로 알려줘”, “리스트 만들어줘” with implied ranking, “가장 많이 … 순서대로”), else 0. | Ranking over many items is perceived as more complex than returning a single best match, potentially increasing acceptable latency. |
| `QL_requires_structured_output` | binary | `queries` | 1 if output format is explicitly structured (e.g., “가계부로 작성해줘”, “쇼핑리스트 만들어줘”, “리스트 만들어줘”), else 0. | Structured outputs require additional formatting and organization; users may expect more processing and accept slightly higher MAL. |
| `QL_reference_to_past_recommendation` | binary | `queries` | 1 if refers to “지난번 … 말했던 …”, “소연이가 추천했던…”, “두산이가 말했던…”, etc., else 0. | Referring to past recommendations implies memory over prior interactions; users may accept more latency for retrieving/aligning with past context. |
| `QL_refers_to_goal_or_target` | binary | `queries` | 1 if mentions explicit goals/targets (“목표 걸음수”, “목표 칼로리”, “목표 칼로리와 운동량”), else 0. | Goal-tracking often feels time-sensitive (e.g., during the day), possibly lowering MAL, but also more complex analytics; feature lets model learn this interaction. |
| `QL_contains_season_ref` | binary | `queries` | 1 if mentions seasons (“봄”, “여름”, “가을”, “겨울”, “여름휴가”), else 0. | Seasonal references usually indicate broader, less time-critical retrospection; users may accept higher latency. |
| `QL_context_phrase_now_here` | binary | `queries` | 1 if includes both temporal and spatial immediacy cues (“지금 여기…”, “현재 위치에서 걸어서 갈 수 있는…”), else 0. | Strong here-and-now coupling typically demands very low latency; delays are more salient and frustrating. |
| `QL_recall_specific_entity` | binary | `queries` | 1 if asking “어디였지/언제였지/무엇이었지/제목이 뭐였지” about a specific past entity (song, restaurant, place, content), else 0. | These feel like simple memory lookups; users expect near-instant answers and lower MAL. |
| `QL_counting_frequency` | binary | `queries` | 1 if asking “몇 번이나 했지?”, “총 얼마나 썼지?”, “몇 시간 재생했지?”, etc., else 0. | Frequency/count queries are simple aggregations over logs; perceived as light analytics, with moderate but not huge tolerance for latency. |
| `QL_language_complexity_proxy` | numeric | `queries` | Ratio of unique tokens to total tokens (type-token ratio) in the query. | Higher lexical variety (within these short queries) may correlate with more nuanced, multi-constraint tasks, increasing perceived complexity and MAL. |
| `QL_has_explicit_constraint_price` | binary | `queries` | 1 if contains explicit price constraint like “10만원 정도”, else 0. | Additional constraints (budget, distance) increase search space complexity but also perceived “smartness”; users might accept slightly more latency. |
| `QL_has_explicit_constraint_time_window` | binary | `queries` | 1 if query specifies usage time window for content (“출퇴근 시간에”, “30분 정도 여유 시간에”), else 0. | Time-windowed content selection is a planning task for a near-future window; users may be somewhat tolerant but still expect responsiveness. |
| `QL_has_explicit_constraint_distance` | binary | `queries` | 1 if mentions walking distance/step-based constraints (“만보 정도 걸을 수 있는”, “걸어서 갈 수 있는”), else 0. | Spatial constraints add filtering but are intuitive; users may perceive moderate complexity and allow moderate latency. |
| `QL_emb_intent_cluster` | categorical | `queries` (via embeddings) | Cluster ID from k-means (or similar) over sentence embeddings, tuned so clusters align with intent families (e.g., recall, stats, compare, summarize, recommend). | Embedding clusters capture nuanced intent patterns beyond keywords (e.g., “비슷한 느낌의 … 추천해줘” vs generic “추천해줘”), which can correlate with different MAL expectations. |
| `QL_emb_complexity_axis` | numeric | `queries` (via embeddings) | Projection of each query’s embedding onto a learned “complexity axis” (e.g., via PCA or supervised regression proxy trained on a complexity label). | Provides a continuous, data-driven estimate of semantic complexity that complements simple length-based features, likely correlated with tolerated latency. |
| `QL_emb_personalization_axis` | numeric | `queries` (via embeddings) | Projection onto an axis separating highly personal-history-based queries from generic/open-domain queries, derived from weak labels (e.g., presence of “내가 자주”, “내 건강 데이터”). | Captures graded personalization beyond binary rules, refining how personalization level relates to MAL. |

---

**Core vs optional**

- **Recommended core set**: all features marked with `★` (they cover length, time/urgency, task type, modality, personalization, history span, external knowledge, location coupling, output size, comparison/summarization/recommendation flags, social context, mobile-likely context, and high-level goal type).
- **Optional features**: the rest, which can be added progressively for richer models or when you have enough data and want finer-grained distinctions and embedding-derived signals.

All features are defined so they can be implemented deterministically from the query text, and each has a clear theoretical link to how humans perceive task complexity, urgency, and thus acceptable waiting time.